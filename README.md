# WebPullWorker - тестовое задание для Kaspersky Container Security

### Краткое описание
В данном задании я реализовал простую очередь задач в го. Реализован базовый веб-сервер с помощью библиотеки net/http, который принимает задачи в очередь и выполняет их пулом воркеров. Дополнительные условия указаны в самом задании.

### Реализация
Конфигурационные данные хранятся в .env, они подгружаются в начале работы программы, реализация в пакете config (при отсутсвии значений или их некорректности используются значения по умолчанию). Логика устройства очереди и взаимодействия с ней описана в пакете queue, реализованы ее состояние и поведение. 

Кратко это выглядит так: мы создаем очередь, передаем в нее параметры из окружения и запускаем. Внутри в этот момент запускается группа воркеров-горутин (имитация выполнения задач) и горутина по проверке под очереди (отвечает за отложенные задачи, у которых временя выполнения еще не подошло).

Задачи поступают через хендлер EnqueueHandler и передаются в канал заданий, который уже непосредственно распределяет их по воркерам. Параллельно с этим изменяется статус задачи. Если при выполнении задания оказалось, что оно провалено, то мы определяем время следующей попытки, увеличиваем счетчик попыток и передаем эту задачу в под очередь отложенных. Если задача выполнена успешно, то просто изменяем статус.

Под очередь отложенных задач реализована следующим образом. Имеем слайс отложенных задач. Каждые 100мс(реализация через получения времени через канал NewTicker.С мы проверяем время каждой задачи, и, если мы уже можем выполнять задачу, то возвращаем ее обратно в основную очередь)

Я реализовал такой алгоритм, потому что потому что задачи, которые не готовы к немедленному выполнению (например, после ошибки и с выставленным временем NextRunAt), не должны занимать воркеров и висеть в основном канале. Если бы я оставил их в общем канале, воркеру пришлось бы проверять время и ждать Sleep, блокируя себя. Это уменьшило бы эффективность — один воркер сидит и ждёт, а остальные простаивают.

### Возможные улучшения
1. Для отложенных задач использовать min-heap. В текущей версии используется слайс, и при каждой итерации прохождения по нему мы распределяем его на waiting и ready, что является излишним. Асимптотика выполнения такой функции O(n). При интегрировании min-heap задачи можно сортировать по NextRunAt, что позволит дойти до максимально выполняющего условие времени и не идти дальше.
2. Добавить хендлер проверки статуса таска GET /status/{id}
который в ответ будет давать его статус 
(в очереди\ в исполнении\ сделано\ отказ).
